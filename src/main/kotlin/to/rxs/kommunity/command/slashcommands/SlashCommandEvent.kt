package to.rxs.kommunity.command.slashcommands

import dev.kord.core.Kord
import dev.kord.core.behavior.GuildBehavior
import dev.kord.core.behavior.MemberBehavior
import dev.kord.core.behavior.UserBehavior
import dev.kord.core.behavior.interaction.InteractionResponseBehavior
import dev.kord.core.entity.Member
import dev.kord.core.entity.interaction.GuildChatInputCommandInteraction
import dev.kord.core.entity.interaction.InteractionCommand
import dev.kord.core.event.Event
import dev.kord.core.event.message.MessageCreateEvent
import dev.kord.x.commands.argument.result.ArgumentResult
import dev.kord.x.commands.kord.model.KordEvent
import dev.kord.x.commands.model.command.Command
import dev.kord.x.commands.model.command.CommandEvent
import dev.kord.x.commands.model.processor.CommandProcessor
import kotlinx.coroutines.flow.*
import to.rxs.kommunity.command.slashcommands.respond.ResponseStrategy

class SlashCommandEvent<T : InteractionResponseBehavior>(
    override val command: Command<*>,
    override val commands: Map<String, Command<*>>,
    override val processor: CommandProcessor,
    val ack: T,
    val strategy: ResponseStrategy,
    val interactionCommand: InteractionCommand,
    override val kord: Kord,
    override val shard: Int,
    private val interaction: GuildChatInputCommandInteraction
) : ResponseStrategy by strategy, CommandEvent, Event {
    val author: UserBehavior get() = interaction.user
    val member: Member get() = interaction.member
    val guild: GuildBehavior get() = interaction.guildBehavior


    /**
     *  Suspends until the user invoking this command enters a message in
     *  the [KordEvent.channel] that is accepted by the given [argument].
     *
     *  ```kotlin
     * command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member.ban()
     *     }
     * }
     * ```
     * > This function doesn't return until a valid value is entered, which might negatively impact user experience.
     * > If this is a concern, consider using the method overload that accepts an escape filter.
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T> read(
        argument: dev.kord.x.commands.argument.Argument<T, MessageCreateEvent>,
        filter: suspend (T) -> Boolean = { true }
    ): T = kord.events.filterIsInstance<MessageCreateEvent>()
        .filter { it.message.author?.id == author.id }
        .filter { it.message.channel.id == interaction.channel.id }
        .map { argument.parse(it.message.content, 0, it) }
        .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
        .filterIsInstance<ArgumentResult.Success<T>>()
        .map { it.item }
        .filter(filter)
        .take(1)
        .single()

    /**
     *  Suspends until the user invoking this command enters a message in
     *  the [KordEvent.channel] that is accepted by the given [argument].
     *
     *  ```kotlin
     *  command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member?.ban()
     *     }
     * }
     * ```
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @param escape a filter that stops this function from taking input when returning true,
     *  making this function return `null`.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T : Any> read(
        argument: dev.kord.x.commands.argument.Argument<T, MessageCreateEvent>,
        escape: suspend (MessageCreateEvent) -> Boolean,
        filter: suspend (T) -> Boolean = { true }
    ): T? = kord.events.filterIsInstance<MessageCreateEvent>()
        .filter { it.message.author?.id == author.id }
        .filter { it.message.channel.id == interaction.channel.id }
        .takeWhile { !escape(it) }
        .map { argument.parse(it.message.content, 0, it) }
        .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
        .filterIsInstance<ArgumentResult.Success<T>>()
        .map { it.item }
        .filter(filter)
        .take(1)
        .singleOrNull()
}
